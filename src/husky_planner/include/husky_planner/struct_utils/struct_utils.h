#pragma once
#include <vector>
#include <cstdint>

/**
 * Node structure representing an individual node in the graph generated by the PRM.
 * This models prm.nodes -> a 4x1 vector storing [x, y, z, node_value AKA locomotion mode]
 * This is also used for nearest_nodes(), storing distance to match the [x, y, z, distance] of nearest_nodes
 */
class Node{
public:
    Node(): x(0.0f), y(0.0f), z(0.0f), distance(-1.f), node_value(0) {}
    Node(float new_x, float new_y, float new_z): x(new_x), y(new_y), z(new_z), distance(0.0f), node_value(0){}
    Node(float new_x, float new_y, float new_z, int n_val): x(new_x), y(new_y), z(new_z), distance(0.0f), node_value(n_val){}
    Node(float new_x, float new_y, float new_z, float dist): x(new_x), y(new_y), z(new_z), distance(dist), node_value(0) {}
    Node(float new_x, float new_y, float new_z, float dist, int n_val): x(new_x), y(new_y), z(new_z), distance(dist), node_value(n_val){}

    void set_coords(float new_x, float new_y, float new_z){
        x = new_x;
        y = new_y;
        z = new_z;
    }

    void add_distance(float new_dist){
        distance = new_dist;
    }
    
    void set_value(int n_val){
        node_value = n_val;
    }

    float get_distance(){
        return distance;
    }
    int get_value() const{
        return node_value;
    }
    float get_x() const{
        return x;
    }

    float get_y() const{
        return y;
    }

    float get_z() const{
        return z;
    }

    void get_coords(float &get_x, float &get_y, float &get_z) const{
        get_x = x;
        get_y = y;
        get_z = z;
    }

    bool operator<(const Node& other) const{
        return distance < other.distance;
    }
private:
    float x, y, z;
    float distance;
    int node_value;
};

/**
 * Edge struct that is a part of the graph output from the PRM.
 * Used in prm_graph.edges within the Planner class.
 */
struct Edge{
    Edge(const Node &from_, const Node &to_): from(from_), to(to_) {}
    Node from;
    Node to;
};

/**
 * The data structure outputted from the PRM, operated on by A*.
 */
class Graph{
public:
    Graph(){}

    /**
     * Adds an edge given a from node and a to node.
     */
    void add_edge(Node &from, Node &to){
        Edge new_edge{from, to};
        edges.push_back(new_edge);
        numb_edges++;
    }
    /**
     * Adds an edge given an edge.
     */
    void add_edge(Edge &e){
        edges.push_back(e);
        numb_edges++;
    }

    /**
     * Iterator to the nodes object.
     * 
     * @return const std::vector<Node>& 
     */
    const std::vector<Edge>& get_edges() const {
        return edges;
    }

    /**
     * Adds a node to the graph.
     */
    void add_node(Node &n){
        nodes.push_back(n);
        numb_nodes++;
    }

    /**
     * Iterator to the nodes object.
     * 
     * @return const std::vector<Node>& 
     */
    const std::vector<Node>& get_nodes() const {
        return nodes;
    }

    /**
     * Getter function for the number of edges.
     */
    uint32_t num_edges() const{
        return numb_edges;
    }
    /**
     * Getter function for the number of nodes.
     */
    uint32_t num_nodes() const{
        return numb_nodes;
    }

private:
    /*
     * Stores the nodes of the graph generated by the PRM.
     * Stores Nodes with node_value.
     */
    std::vector<Node> nodes;
    uint32_t numb_nodes = 0;

    /*
     * Stores the edges of the graph generated by the PRM. 
     * From Edge contains Node with node_value, To Edge contains Node with distance. 
     */
    std::vector<Edge> edges;
    uint32_t numb_edges = 0;

};

/*
 * 'open' vector in a_star: [is_open, x, y, z, x1, y1, z1, g_cost, h_cost, f_cost]
 * 'exp_array' vector in a_star: [x, y, z, g_cost, h_cost, f_cost]
 */
struct AStarNode{
    /*
     * This constructor applies to the open vector in run_a_star(), which cares about is_open.
     */
    AStarNode(uint32_t o, Node c, Node p, float g, float h, float f): is_open(o), curr(c), parent(p), g_cost(g), h_cost(h), f_cost(f){}
    /*
     * This constructor applies to the open vector a lazy implementation for Node construction.
     */
    AStarNode(uint32_t o, float x_1, float y_1, float z_1, float x_2, float y_2, float z_2, float g, float h, float f): is_open(o), curr(x_1, y_1, z_1), parent(x_2, y_2, z_2), g_cost(g), h_cost(h), f_cost(f){}
    /*
     * This constructor applies to the exp_array vector in run_a_star(), which doesn't care about is_open but uses all other inputs.
     */
    AStarNode(float x, float y, float z, float g, float h, float f): is_open(0), curr(x, y, z), parent(), g_cost(g), h_cost(h), f_cost(f){}
    uint32_t is_open;
    Node curr; // x, y, z
    Node parent; // x, y, z

    /*
     * Costs stored by each open and exp_array vector.
     */
    float g_cost;
    float h_cost;
    float f_cost;
};

/*
 * Utils for the environment bodies to visualize in Rviz.
 */
struct Vec {
    float x, y, z;
};

struct Body {
    float x_min, x_max;
    float y_min, y_max;
    float z_min, z_max;
};
